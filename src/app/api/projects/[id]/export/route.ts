import { NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import { isPro } from "@/lib/tiers";
import { jsPDF } from "jspdf";
import autoTable from "jspdf-autotable";

// GET /api/projects/[id]/export - Export feedbacks as CSV or PDF (Pro only)
export async function GET(
    request: Request,
    { params }: { params: Promise<{ id: string }> }
) {
    try {
        const session = await auth();
        const { id } = await params;
        const url = new URL(request.url);
        const format = url.searchParams.get("format") || "csv";

        if (!session?.user?.id) {
            return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }

        // Check if user is Pro
        const userIsPro = await isPro(session.user.id);
        if (!userIsPro) {
            return NextResponse.json(
                {
                    error: "Export is a Pro feature. Upgrade to export your feedback data.",
                    code: "PRO_FEATURE_REQUIRED",
                },
                { status: 403 }
            );
        }

        // Verify project ownership
        const project = await prisma.project.findFirst({
            where: {
                id,
                userId: session.user.id,
            },
        });

        if (!project) {
            return NextResponse.json({ error: "Project not found" }, { status: 404 });
        }

        // Fetch all feedbacks for the project
        const feedbacks = await prisma.feedback.findMany({
            where: { projectId: id },
            orderBy: { createdAt: "desc" },
        });

        const dateStr = new Date().toISOString().split("T")[0];

        if (format === "pdf") {
            // Generate PDF using jsPDF
            const doc = new jsPDF();

            // Header
            doc.setFontSize(20);
            doc.setTextColor(23, 23, 23);
            doc.text(project.name, 14, 22);

            doc.setFontSize(10);
            doc.setTextColor(115, 115, 115);
            doc.text(`Feedback Report - Generated on ${new Date().toLocaleDateString()}`, 14, 30);

            // Stats summary
            const totalFeedback = feedbacks.length;
            const unreadCount = feedbacks.filter(f => !f.isRead).length;
            const bugCount = feedbacks.filter(f => f.category === 'bug').length;
            const featureCount = feedbacks.filter(f => f.category === 'feature').length;

            doc.setFontSize(12);
            doc.setTextColor(23, 23, 23);
            doc.text(`Total: ${totalFeedback}  |  Unread: ${unreadCount}  |  Bugs: ${bugCount}  |  Features: ${featureCount}`, 14, 42);

            // Table data
            const tableData = feedbacks.map(fb => [
                fb.category.charAt(0).toUpperCase() + fb.category.slice(1),
                fb.message.length > 60 ? fb.message.substring(0, 57) + "..." : fb.message,
                fb.userEmail || "-",
                fb.isRead ? "Read" : "Unread",
                new Date(fb.createdAt).toLocaleDateString()
            ]);

            // Add table
            autoTable(doc, {
                startY: 50,
                head: [["Category", "Message", "Email", "Status", "Date"]],
                body: tableData,
                headStyles: {
                    fillColor: [23, 23, 23],
                    textColor: [255, 255, 255],
                    fontSize: 9,
                    fontStyle: "bold",
                },
                bodyStyles: {
                    fontSize: 8,
                    textColor: [51, 51, 51],
                },
                alternateRowStyles: {
                    fillColor: [250, 250, 250],
                },
                columnStyles: {
                    0: { cellWidth: 25 },
                    1: { cellWidth: 75 },
                    2: { cellWidth: 40 },
                    3: { cellWidth: 20 },
                    4: { cellWidth: 25 },
                },
                margin: { top: 50 },
            });

            // Footer
            const pageCount = doc.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setTextColor(163, 163, 163);
                doc.text(
                    `Generated by Feedinbox â€¢ Page ${i} of ${pageCount}`,
                    doc.internal.pageSize.getWidth() / 2,
                    doc.internal.pageSize.getHeight() - 10,
                    { align: "center" }
                );
            }

            // Get PDF as buffer
            const pdfBuffer = Buffer.from(doc.output("arraybuffer"));

            return new NextResponse(pdfBuffer, {
                status: 200,
                headers: {
                    "Content-Type": "application/pdf",
                    "Content-Disposition": `attachment; filename="${project.name}-feedbacks-${dateStr}.pdf"`,
                },
            });
        }

        // Default: Generate CSV
        const headers = ["ID", "Category", "Message", "User Email", "Page URL", "Status", "Created At"];
        const rows = feedbacks.map((fb) => [
            fb.id,
            fb.category,
            `"${fb.message.replace(/"/g, '""')}"`, // Escape quotes in message
            fb.userEmail || "",
            fb.pageUrl || "",
            fb.isRead ? "Read" : "Unread",
            fb.createdAt.toISOString(),
        ]);

        const csv = [
            headers.join(","),
            ...rows.map((row) => row.join(",")),
        ].join("\n");

        return new NextResponse(csv, {
            status: 200,
            headers: {
                "Content-Type": "text/csv",
                "Content-Disposition": `attachment; filename="${project.name}-feedbacks-${dateStr}.csv"`,
            },
        });
    } catch (error) {
        console.error("Error exporting feedbacks:", error);
        return NextResponse.json(
            { error: "Failed to export feedbacks" },
            { status: 500 }
        );
    }
}

